# 进程间通信方式

进程间通信(IPC)的方式有：管道、信号、消息队列、共享内存、信号量、套接字。

-----
### 管道

管道分为两种：无名管道(简称管道)、命名管道(简称FIFO)。

**1、无名管道**

无名管道，简称**管道**。管道是一种特殊文件，由内核实现，它不依赖于任何文件系统，且只存在于内存。其大小一般为一页，即4KB，不能扩展，如果写满了再继续写的进程就会阻塞。管道是先进先出式的半双工容器，一般是用于单方向的通信，数据被读走后会自动删除管道内的数据，而双向通信则需要靠其他机制方式保证通信的正确性，不如考虑用两条管道。

众所周知，父子进程可以共享所有已打开的文件，包括每个文件中的位置指针。管道的读写两端可以单独关闭，这不会影响另一进程的读写，也就意味着一个进程能对其两端都进行读写，只有在所有打开的句柄都关闭后才是真的关闭。如果读写顺序不对，将得不到预期的结果。

**无名管道只能用于有亲缘关系的进程之间的通信**，比如父子进程之间。为什么？当某个进程创建了一个无名管道，由于父子进程是共享句柄`fd`的，管道也是以句柄形式进行操作的，所有通过fork产生的进程就可以共享这个管道。管道是由内核实现的，其他非亲缘进程无法找到这个管道。

管道的实现是借助了文件系统的file结构和VFS的索引节点inode，由于一般用于多进程的通信，内核实现管道时也会用锁来保证管道的操作，具体实现详见内核源文件`pipe.c`。


以下是一般用法：
```
    int fd[2];  // 句柄
    pid_t pid;
    pipe(fd);   // 创建管道
    if((pid=fork())<0) {
        return 0;           // fork失败
    } else if(pid>0) {
        close(fd[0]);       // 父进程：只写，关闭读
        write something to fd[1];
    } else {
        close(fd[1]);       // 子进程：只读，关闭写
        read something from fd[0];
    }
```



**2、命名管道**

命名管道，简称FIFO。它也是一种特殊的文件，存在于文件系统中，比无名管道要复杂一些，在使用之前需要先用mkfifo函数创建一个命名管道，然后才能用open、close、read、write函数对该管道进行操作。

Linux终端就能使用mkfifo命令，举个例子：
```
# 终端1
$mkfifo ~/test
$cat ~/test
```
敲完命令后会阻塞，这是正常的，因为管道里没有内容，所以读命令就会**阻塞**。此时在另一个终端中输入命令：
```
# 终端2
$echo 'this is message' > ~/test
```
终端1就可以看到输出了`this is message`，并且**不阻塞**了。这是命名管道的一种使用方式。在`~/`目录下，终端敲入`ls -l`可以看到多了个文件`test`，其第一列还写着`prw-rw-r--`，首字符`p`表示了这是个管道文件，这个文件会一直存在，直到你删除了它。要是在某个写操作阻塞的时候，直接`ctrl+c`终止它会怎样？不会有问题的，只是再对其读操作时，会发现之前所写内容并不在该管道中。其他详细信息可用`stat ~/test`查看。

FIFO以文件形式存在，但是它不支持lseek等这些违反其特性的函数，只能开、关、读、写这几种，而这些操作就需要考虑到是否以阻塞形式打开FIFO了，默认情况下是阻塞的，即调用open函数时会阻塞，直到该FIFO被写入了东西。不难想到其他的read、write函数也是这样的流程：读写操作在时间上有重合时才会阻塞返回。open函数也可以指定为非阻塞打开，之后就可以非阻塞读写了，比较方便，具体请参考其他资料。

FIFO中有两个数字需要关注，一个是`pipe capacity`，另一个是`PIPE_BUF`(或`pipe size`)。后者比较好查证，终端命令`ulimit -a | grep "pipe"`或者用C程序打出PIPE_BUF这个宏，Linux一般是4KB。而前者需要通过程序验证，在C中以非阻塞方式创建一个FIFO，一直写到返回错误`Resource temporarily unavailable`就是满了，我的机子测试结果为64KB。前者表明了管道的最大容量，而后者表明了保持原子性写操作的极限，超过PIPE_BUF大小就无法保证原子性。注：想彻底了解管道还需看内核源码。

关于PIPE_BUF有这样几个规定：

- POSIX.1-2001 says that write(2)s of less than PIPE_BUF bytes must be **atomic**. Writes of more  than  PIPE_BUF bytes may be nonatomic.
- POSIX.1-2001 requires PIPE_BUF to be at least 512 bytes(On Linux, PIPE_BUF is 4096 bytes).

具体参考`man 7 pipe`手册的PIPE_BUF项。

FIFO主要用于非亲缘关系的进程之间进行通信，它虽以文件形式存在于系统中，但是使用`stat ~/test`可以发现它的大小始终为0，其实它的缓冲区是存在于内存的，读写操作直接在内存中进行，所有读写都不经过磁盘。



-----
### 信号

信号一般是指信号量，




