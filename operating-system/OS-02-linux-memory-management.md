# Linux内存管理机制

Linux管理内存所用的算法是Buddy算法和Slab算法。

### Buddy 算法

Buddy算法亦称为伙伴算法，此算法是管理空闲物理内存的策略，算法一般有两个要求：
- 分配时能快速找到一块合适的内存分配出去
- 回收时能方便管理，包括尽量少产生内外部碎片等等

算法的原理：假设整个系统有连续的4GB可以分配，先将这4GB看作为一个段，此段大小为2^32^，也就是2^20^个物理内存块，将它挂在队列queue[20]中。如果此时有进程需要申请1个块，即4KB大小，那么搜索queue[1~20]发现只有queue[20]有内存，则将刚挂上去的4GB切分成两个2GB的段，其中一个挂到queue[19]，另一个再切分成两个1GB的段，其中一个挂到queue[18]上，另一个继续切分，以此类推，直到切分到粒度为4KB为止，将其中一段4KB的分配出去，剩下一段挂在queue[1]上。如果接着又有一个进程需要申请1.6个块，那就需要分配给它2个块，即8KB大小，那么直接在queue[2]上摘下一个即可。这就是分配的过程。而回收的过程就是分配的逆过程，比如进程先释放了最后申请的8KB，那么就将它挂在queue[2]上，然后啥都不做；接着进程又释放了最开始申请的那4KB，此时将它挂在queue[1]上，刚好里面还有一个段，一直合并到4GB，挂在queue[20]上。

那什么情况下回收内存段就可以合并呢？其实是用位图来记录的，一位代表一块，如果两个相邻的位均为0,那就代表可能可以进行合并了，仅是可能！具体看例子。

假设有8个位的bitset来记录8个内存块的分配情况，如下

| bit | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 |
|-----|---|---|---|---|---|---|---|---|
| val | 0 | 1 | 0 | 0 | 1 | 0 | 0 | 1 |

val=0表示空闲，val=1表示已分配出去，来看看哪些可以合并。第3和第4可以合并，第6和第7不能合并。过了一会，bitset情况又发生了变化，如下

| bit | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 |
|-----|---|---|---|---|---|---|---|---|
| val | 0 | 0 | 0 | 0 | 0 | 1 | 0 | 1 |

第1、2、3、4块是可以合并的，而第5是无法同左边合并的。观察一下其实可以发现，很想一棵满二叉树，只有父亲节点相同的块才可以合并，用一个表来表示如下

| bit | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 |
|-----|---|---|---|---|---|---|---|---|
| val | A | A | B | B | C | C | D | D |
| val | E | E | E | E | G | G | G | G |
| val | Y | Y | Y | Y | Y | Y | Y | Y |

同个字母表示可以合并，每次合并必须所有同样的字母一块合并，如合并G，则必须第5～8块才行，合并Y，那就需要第1～8这8块才能合并。下面这个图大概表达的就是这样的思想：

![image](https://github.com/xcw0754/coder-skills/blob/master/pics/OS-02-linux-memory-management-01.png)


### Slab 算法

附上参考文章 [点我直达1](https://www.cs.rutgers.edu/~pxk/416/notes/09-memory.html) [点我直达2](https://www.kernel.org/doc/html/latest/)

由于Buddy算法在分配小内存时很不理想，大块的内存很快耗光，小内存段过多又很难合并，导致产生内部碎片，就申请不到大内存段了。比如很多情况下都只申请100B左右的内存，而每次都给分配4KB，非常浪费。故有了Slab算法，它管理通用数据结构的分配，用复杂的管理方式来达到节约内存、快速分配的效果。也称作Slab层，Slab分配器等。

Slab分配的粒度是对象，说白了就是特定的结构体，比如FCB、TCB、信号量、socket、inode等等，这些很通用的对象，如果用Slab来管理对象池，速度和碎片问题都能比较好的缓解。Slab就像零售商一样，去批发商Buddy那里拿到一批内存，然后制作成对象后进行零售。

实现Slab算法有几个结构需要认识，分别是
- slab。表示一个连续的内存段，通常是从Buddy批发来的几个块(通常1个块)。
- kmem_cache。表示由若干个slab组成的集合。
- chain。表示由若干个kmem_cache组成的一条链。

直观来讲，chain包含了多个kmem_cache，而kmem_cache又包含了多个slab。认识完这3个主要的结构，再稍微细化一下。kmem_cache中并不是直接由slab构成的，要区分为以下三种状态：
- full。已经使用了的slab的集合。
- partial。使用了的slab，和空闲的slab都有。
- empty。空闲的slab的集合。

其实每种状态里面才是直接放的slab，每个slab所表示的内存就可以用于存放对象，同个slab中的对象大小是一样的。

分配对象的过程是这样的，首先从partial中找相应的slab，如果有则分配；如果找不到，那就在empty中找相应的slab，找到则分配；如果这都没有找到，那就只能再去找Buddy批发了。

关于具体的算法实现，很少书籍讲得详细，还是看书配合看源码吧。







