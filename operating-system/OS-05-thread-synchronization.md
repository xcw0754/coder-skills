# 线程同步

线程同步方式有信号量、互斥锁、自旋锁、读写锁、屏障、条件变量、令牌。


### 信号量 semaphore

信号量一般用于表示资源，比如有两个进程A和B协同工作，A负责生产产品，B负责消费产品，它们之间有明显的同步需求，当且仅当A生产了产品之后，B才能进行消费，这样就可以使用信号量来表示产品，A每次生产一个产品后就将信号量自增，此时B就可以获取信号量，产品数量为零时，B想要获得信号量就会阻塞，直到A将信号量自增。当用信号量表示一个资源时，它就可以当作互斥锁来用了，但是这样不是太保险，比如代码写错了就可能会表示2个资源，这纯粹靠人工保证的，所以最好还是用互斥锁实现这样的效果。

### 互斥锁 mutex

互斥锁很常见于临界资源的共享，当资源仅有1个的时候，可以使用一个互斥锁表示资源，锁的拥有者具有临时的资源使用权，使用完资源之后释放锁，以便其他线程使用该资源，其他线程若获取不到该锁就会阻塞。和信号量的区别是，互斥锁只能用来表示一个资源，它要么为0要么为1。

### 自旋锁 spin lock

自旋锁与互斥锁类似，都是表示单个资源的锁，不同的是自旋锁会忙等待，一直检测锁是否已经打开，这样就会导致CPU浪费。其实自旋锁有其适用的情况，一般用于多核CPU上，在上锁时长较短于线程切换时间时很有用，比如某核上的线程加锁后立刻就解锁了，时间极短，不超出一个时间片，此时其他核上的线程就能在被调度出去之前得到锁，从而节省了时间。自旋锁在内核中用的比较多。

### 读写锁

读写锁顾名思义就是读写时用的锁，写锁是互斥的，与mutex类似，读锁是共享的，类似于信号量。在写次数极少的时候使用读写锁的效率很高，因为写锁锁住一个资源会导致其他线程无法使用该资源，而读锁锁住一个资源只会导致写线程阻塞，而读线程可以正常工作，这样其实就是读优先，如果一直有读线程锁住该资源，那么写线程将一直写不了。

### 屏障 barrier

屏障比较少见，有一个典型的模型：某个宝藏的大门需要三个人的共同努力才能打开，这个门就是屏障，当且仅当这三个人全部到齐了才能打开门，打开门之后它们就各干各的事了(并发)，不受其他限制。

### 条件变量

条件变量刚接触时比较难理解它存在的意义，其实它也是用于实现同步的，功能类似于信号量，常见的场景是利用一个互斥量和一个条件变量实现生产者/消费者模型。条件变量比信号量要轻量级，因为它本身不具备原子性，需要一个互斥量来保证操作条件变量时的原子性，而信号量本身就具有原子性。条件变量的使用可以更加灵活，比如刚说的搭配一个互斥量就能实现信号量所提供的功能，流程大致如下：
```
// 线程A、线程B、...
lock(mutex);
while(isFalse)
	wait(condVar, mutex);	//阻塞等待
do sth;		//执行互斥的一些操作
unlock(mutex);
```
这看起来condVar就是个队列，每个线程用的是同个condVar，在wait时就像将线程挂在condVar一样，等待唤醒，唤醒之后还得继续检查(while循环)是否可以进行操作(do sth)，这是因为有些系统(极少)为了实现条件变量又要保持效率，导致了可能会误醒(就是没有被notify的线程在wait时竟然返回了)，为了避免这种情况，加个while比较有保证一些。notify还可以唤醒所有正在wait的线程(可选，一般都有这个功能)。

那这个效果和只用mutex有啥区别？如果将上面代码中的第二第三行去掉，mutex不是也能实现互斥地do sth吗？先回顾一下mutex的特性，mutex是个锁而已，只有两种状态：锁住、解锁。它是没有类似notify的功能的，比如锁住一个资源之后使用完再解锁，实现的仅仅是互斥的效果，压根没有同步效果(同步效果应该是信号量那样的)。其实就是条件变量弥补了互斥锁的不足，设计出互斥锁、条件变量、信号量是为了适应不用的需求，虽然它们能实现一个效果，这就像do while和while的区别一样，效果都是循环，各有用处，但使用起来更灵活。

了解到这里仍有一个疑问，就是mutex只有一个，而且lock和unlock包起来整个操作，那怎么还会可能出现多个线程在wait的情况呢？按理说应该只有一个在wait，而其他都在lock就被阻塞了的。看到`wait(condVar, mutex);`中的mutex了吗？wait其实做的操作是如下三步：
- 1、unlock(mutex)
- 2、real_wait(condVar);
- 3、lock(mutex)

所以这样就可能会有多个线程同时阻塞在real_wait处了，此时某个线程可以选择唤醒其中一个或者全部等待线程。


### 令牌

令牌跟网络中的令牌环的原理相似，就是以令牌传递的方式实现同步，比如四百米接力赛一样，拿到棒的就可以跑，呈现出来一个环形传递过程。



select d1, a, b from 
(select date as d1,count(*) as a from table where B='胜' group by date) as T1 
join
(select date as d2,count(*) as b from table where B='败' group by date) as T2
on date