# 虚函数与纯虚函数

### 虚函数

在类的某个成员函数声明之前加一个virtual关键字就能将该函数声明为虚函数。如下
```
class Base {
public:
	virtual void f() {};	//这就是虚函数
};
```
有什么用？
> 实现多多态。就是说，如果有一个类D继承了Base，我可以用基类指针`Base *p = new D`指向派生类D，在程序运行时会自动决定要调用Base的函数f还是D的函数f。具体怎么决定，分情况：
- 如果基类Base有虚函数f，派生类D没有重写。那么运行时调用D的f。
- 如果基类Base有虚函数f，派生类D重写了它。那么运行时调用Base的f。

严肃地再问一遍：有什么用？
> Well，讲实用性。
> 当我想访问所有的Base的各种派生类D，E，F，G...中的函数f，我只能创建各种各样的指针来逐个遍历吗？显然可以用虚函数的这种多态性啊。
> 用游戏世界的通俗比喻：基类Animal表示怪物，各种具体的怪物都要继承Animal，这些怪物都有共同的行为“被打时受伤的动作"。众所周知，场上的怪物有蜘蛛、狼、兔子等等，受伤动作不能那么单一，不然游戏谁玩？
> 那么我只需要用一个基类Animal指针，就能指向各种怪物，调用它们的扣血动作接口，这不是很方便吗？


推荐这篇文章[C++ 虚函数表解析](http://blog.csdn.net/haoel/article/details/1948051/)，看完就能对虚函数的实现有清晰了解。

### 虚函数的某些细节

上面推荐的文章读完了吗？读完来看看一个新的问题。
```
class A
{
public:
    virtual void show(int a=10)
    {
        cout<<"这是A "<<a<<endl;
    }
};

class B: public A	//继承
{
public:
    void show(int b=11)
    {
        cout<<"这是B "<<b<<endl;
    }
};

int main()
{
    B *tmp = new B;
    A* p = tmp;
    p->show();		//输出：这是B 10
    tmp->show();	//输出：这是B 11
    return 0;
}
```
对这个输出结果很疑惑吧。在提供了默认参数之后出现的结果竟有些意外，事实上，`p->show()`调用的是类B的函数，但是默认参数却是A中的，可以认为函数与参数分离，在调用类B的show(int)函数时，编译器仍用将10传给show，而不是像基类的show被顶替掉一样的原理。
这涉及到静态绑定和动态绑定。具体参考[深入理解C++的动态绑定和静态绑定](http://blog.csdn.net/chgaowei/article/details/6427731)

除了以上提到的内容之外，还有一个细节需要注意。当基类使用了虚函数后，别忘了把基类的析构函数也变成虚函数，否则调用的仅仅是基类的析构函数，这样派生类中的变量就没有被释放，有泄漏的风险。看例子：
```
Son *p = new Base;
delete p;	//调用析构函数
```
如果定义了基类的虚析构函数，那么`delete p`会先调用Son类的析构函数，再调用Base的析构函数，这样才是正确的析构过程，符合普通继承的析构过程。
Tips：构造函数的调用次序是基类先于派生类，析构函数的调用次序是派生类先于基类。析构函数是不能抛异常的。

### 虚函数和其他成员函数的关系

先看如下的例子
```
class Base
{
public:
    void base1() { Foo(); } // 成员函数
    virtual void Foo() { cout<<"基类"<<endl; }
};

class Derive : public Base
{
public:
    void derive1() { Foo(); } // 普通函数
    void Foo() { cout<<"派生类"<<endl; }
};

int main()
{
    Base* p = new Derive();
    p->base1(); // 输出：基类
    return 0;
}
```
这个例子可以看出，基类的成员函数中调用虚函数，在运行时仍是调用派生类中的成员函数。结果说明动态绑定在成员函数中仍然生效，基类的虚函数会自动替换成派生类中的同名函数。那么在构造函数中也这样吗？稍微改一下上面的例子：
```
class Base
{
public:
    Base() { Foo(); } // 改成：基类构造函数
    virtual void Foo() { cout<<"基类"<<endl; }
};

class Derive : public Base
{
public:
    Derive() { Foo(); } // 改成：基类构造函数
    void Foo() { cout<<"派生类"<<endl; }
};

int main()
{
    Base* p = new Derive();
    return 0;	// 输出：基类 派生类
}
```
先输出的"基类"，后输出"派生类"。明显在构造函数中已经没有动态绑定了，否则应该都输出"派生类"。正因为是构造函数，在生成对象的时候是先调用基类的构造函数，此时派生类还没有形成，是绑定不到派生类的Foo()的，所以输出"基类"。其实，析构函数也类似，当执行到基类的析构函数时，派生类已经不存在了，你再去调用派生类的Foo()肯定会出问题的，至于是什么问题，请尝试。

所以，不应该在构造or析构函数中调用虚函数，否则达不到预期的结果。



-----
### 纯虚函数

纯虚函数和虚函数有些不一样。一般是这样定义的
```
class Base {
public:
	virtual void f() = 0;	//纯虚函数，看清楚行尾
};
```
先上一个概念：抽象类是指含有纯虚函数的类。
规定：抽象类不能生成实例，只能被继承，而且继承它的类都必须实现里面声明的纯虚函数，这是强制规定。

> 在很多情况下，基类本身实例化是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理，以马克思主义来讲，它是对creature的最高抽象，是一个抽象的概念，不是具体实际存在的，哈哈哈。

推荐这篇文章[虚函数和纯虚函数的区别](http://blog.csdn.net/hackbuteer1/article/details/7558868)，看完就能知道纯虚函数到底纯在哪里。


-----
### 总结

- 纯虚函数和虚函数都是实现多态的途径。
- 它们既有相似之处，也有不同之处。






