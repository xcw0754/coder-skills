# C++语法中的小坑

### Q1：数组的地址
```
int a[] = {1,2,3};
int *b = a;
```
- `sizeof(a)`等于多少？
答案3,因为a是数组，包含3个元素。
- `sizeof(b)`等于多少？
答案4,因为b是指针，指针在32位系统上占4字节。
- 如果将a作为参数传到函数中去，那么效果是和`int *b = a`一样的，小心辨别。


-----
### Q2：字符串的地址

```
char str1[] = "abc;
char str2[] = "abc"
char *str3 = "abc";
char *str4 = "abc";
```
- `(str1==str2)`是否为true？
不是的。这是两个数组，内容是可以随时改的，所以str1和str2是两个数组各自的地址。
- `(str3==str4)`是否为true？
是的。它们都指向同一个字符串常量，在C++中字符串常量一样就必然仅有1份拷贝。

### Q3：指针的大小一定是4B吗？(32位系统)
不是的，CPP中的函数可分为普通函数和成员函数，普通函数一般是占4B的，而成员函数就未必，视编译器而定，一般大于4B。因为成员函数是在类中的，它需要记录更多的信息，故普通指针的大小已经不能满足其需要了。（PS：用g++试了一下是8B，普通指针4B）



# C++的技巧

### Q1：结构体的末尾定义一个空数组有什么用？

看看下面这种写法：
```
struct node {
    int idx;
    int a[];  //空数组
};
```
它的大小在32位系统下sizeof(node)为4，也就是说a是不占空间的，但是它还能用！看下面这个使用例子
```
node *p = (node*)malloc(sizeof(node) + sizeof(int)*100); //申请内存
for(int i=0; i<100; i++)  p->a[i] = i*i; //用操作符[]
```
这样的结构体node就可以省下一个指针大小的空间，又能有指针的效果。当然，如果需要指向其他内存就无力了。假如将a改成指针呢？看下面
```
struct node {
    int idx;
    int *a;  //指针
};
node *p = (node*)malloc(sizeof(node) + sizeof(int)*100); //申请内存
p->a = (int*)&(p->a) + sizeof(int*);   // 必须调整指向
for(int i=0; i<100; i++)  p->a[i] = i*i; //用操作副符[]
```
这样的node它的大小在32位系统下sizeof(node)为8，就不适合用malloc申请连续内存的写法了，否则也没发挥其真正的作用，白浪费这4B的空间。一般用在数组和node分离的情况下，用node中的a来指向数组。
注有个细节：
- 结构体node中若只定义了`int a[]`，则`sizeof(node)`结果为0；
- 结构体node中若为空，则sizeof结果为1；
- 类与结构体一样。

### Q2：不用乘除法实现向上取整至n的倍数。

在STL的内存池中经常需要将某个数字n向上取整至8的倍数，写起来非常快速`x = (n+7)/8*8`，但这用到了乘除法，速度很慢。可以考虑这样实现
```
x = ( n + 7 ) & ~7
```



