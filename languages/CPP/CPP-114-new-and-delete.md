# new和delete关键字

new和delete是一对C++的关键字，有new就有delete，它们总是成对出现。new用于申请内存，delete用于释放内存。

-----
### 关于new

new申请的动态内存是位于堆中的，连续的一块，堆在虚存中是从小地址到大扩展的。在用new申请内存时需要声明类型，如`int *a = new int`，这是默认初始化的，也可以选择显式初始化，如`int *a = new int(8)`。申请数组如`int *a = new int[2]()`。申请内存的新初始化方式见C++11。

注意一个细节，`int *a = new int[0]`会返回一个非零的值，也就是一个指针，而且每次这样的申请都返回不带重复的。其实指向堆中内存的指针有点危险，`*(a+2)=2`这样就可以改了堆中的某个内存。

如果想申请内存，又不想在申请时就初始化(耗时？)，那么可以考虑C++标准库提供的allocator类。

-----
### 关于delete

由于new有初始化功能，而delete自然有析构的功能。其他没有太多可注意的，有new就有delete，别忘了就好。


-----
### new和malloc有什么区别

malloc是C中的申请内存的库函数，它封装了系统调用brk。
相同之处：
- 都是在堆中分配内存


不同之处：
- new是个操作符，operator new支持重载；malloc只是个库函数，没法重载。
- new分配内存时需要指定类型；malloc分配内存只需要指定内存大小。
- new分配的内存还会初始化，若是类还会调用构造函数；malloc申请的内存连清零都没有。
- new内存时会返回指定类型对象的地址；malloc的内存是无类型的。
- new失败会抛异常bad_alloc，但可以用`nonthrow`；malloc失败直接返回null，故使用需前先检查。
- new只能在C++中用；malloc可以在C和C++中用。



-----
### 原理

**new实现原理**

new操作符申请内存的过程其实也是调用malloc来实现的内存分配，它只是增加了一些东西，比如申请内存失败会抛异常，还可以设置申请失败handler，就是回调函数，等等。它还是可以被重载的，注意重载不是说你可以把`new`变成`int`的别名从而用于`new a = 2`，这不行。你能做的只是实现一个申请内存的过程，就是operator new()，那么以后用new运算符时就会调用这个函数。(后面有讲)

对于new内建对象会不会进行值初始化呢?见下面的写法:
```
int *p1 = new int;      // 不会进行初始化，无法保证打印结果为0
int *p2 = new int();    // 会进行值初始化，打印结果为0
int *p3 = new int(99);  // 会进行值初始化，打印结果为99
```

如果你在Linux平台G++打印`new int`一直为0，我建议你用栈内存来测试，即`new(buf) int`，其中buf是栈内存。

对于new对象，每次都会进行初始化，即调用构造函数，无论带没带括号都一样。

其实new是个运算符，而operator new是个运算符函数，用new就会调用这个函数，然后里面才调用malloc。所以重载可以像普通函数一样写，这样会替换掉全局的new，也可以写在类里面，仅适用于该类。如果malloc返回0，即没有申请成功，会调用handler(有handler就不会抛异常了)，再继续malloc。

可参考[C++中的new和delete真的复杂吗？(上)](https://www.jianshu.com/p/8239fba221ab)



**delete实现原理**

delete的实现原理从new的实现原理也能猜到八成了，就是先调用析构函数再调用free函数释放内存。简单的类型如int、double等直接free掉即可。

delete再深究一下，如果使用`malloc(10)`申请内存，那么编译器编译后真正申请的内存往往不止10个字节，而是偏大一些，用于记录你申请了多少内存，还有其他的信息，具体因编译器而异，记录方式也不同。delete也就有多种实现方式，也得防止你重复delete。针对G++编译器改日再测试一下。

可参考[C++ delete[] 是如何知道数组大小的？](https://www.zhihu.com/question/25556263)











