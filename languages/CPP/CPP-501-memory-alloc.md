# STL内存池

STL自己有内存池就是为了加快申请内存的速度，以及减少分配时内部碎片的产生。内部碎片就是分配给你的比你所请求的还要多，而你用不到，其他人又不能用。比如系统分配物理内存是以块为单位的，若进程需要的内存小于1块，就是会这样。

### 分配原理

首先要区分一下，在STL中才会使用STL的内存池，如果程序中没有包含任何STL的头文件，申请的内存就完全和STL内存池没有关系，因此，程序中申请内存分两种：STL、非STL。也就是STL内存池只管理STL中所使用的内存池，其他的不归STL管。

STL分配器有
- 一级分配器。使用malloc()等C函数。
- 二级分配器。使用自己管理的内存池。

当需要需要的内存块超过128B时，使用一级分配器分配内存，此时使用malloc等C函数，这是由系统内核进行内存分配及管理的，当然，释放时会用free函数立即释放。如果需要的内存没有超过128B，则使用二级分配器。STL的二级分配器有一套自己管理内存池的办法，下面讲的都是二级分配器。先来思考一些问题：

- STL中是怎样管理空闲内存的？
- 如果free_list的内存充足，在STL中申请内存时怎么样？
- 如果free_list对应的链表为空，在STL中申请内存时怎么样？
- 如果STL内存池都不足了，申请内存时怎么样？
- 如果堆内存不足时，申请内存时会怎么样？
- 释放内存时，STL需要对其进行回收管理，它怎么区别这是多大的内存？


现在来了解这些问题是怎么解决的。设申请者要申请的内存大小n为8的倍数，如果不是，那就上整至8的倍数，问题不大，下面用到的n均如此假设。

Q1：STL中是怎样管理空闲内存的？

> STL中关于内存有两个地方需要区分，一个是STL内存池，一个是free_list。
> 1. 内存池是一块连续的大内存，仅有一块，由STL用malloc()申请得到的，
> 2. free_list分为16档，分别有8B、16B、24B、32B、40B、...、128B，用一个指针数组`OBJ *free_list[16]`管理起来，每个元素都是链表的头指针。
> 
> 这两个都是由STL自己维护的。

Q2：如果free_list的内存充足，在STL中申请内存时怎么样？

> 若有申请内存的请求，则以申请内存大小n向上取整至8的倍数，比如申请7B就给8B，申请120B就给128B。再从free_list中找到对应大小的链表，再从该链表中分离出一块给申请者。

Q3：如果free_list对应的链表为空，在STL中申请内存时怎么样？

> STL会用chunk_alloc()从STL内存池中申请一块大内存，默认是20*n个字节，然后将内存切小，分配20块中的1块给申请者，剩下的19块插到free_list中。

Q4：如果STL内存池都不足了，申请内存时怎么样？

> STL只能通过chunk_alloc()操作STL内存池，虽然每次默认申请20块n字节的连续内存，但是有几种情况：
> - 当STL内存池等于n字节时，那就会分配这一块，没有refill内存池；
> - 当STL内存池大于n字节且小于20*n字节时，能分配几块就几块，没有refill内存池；
> - 当STL内存池小于n字节时，将这丁点内存(如果有的话)丢到free_list中，再使用malloc()重申请一块大内存作为内存池，再重新执行分配的流程。即有refill内存池。
> 
> 每次refill的内存块大小是多少呢？由两个因子决定，分别是
> 1)申请者的申请量，设为a字节。
> 2)迄今为止已申请堆内存的量，设为b字节。
> 公式为`bytes_to_get = 2*a + ROUNDUP(b>>4)`，其中ROUNDUP是得到8的倍数。

Q5：如果堆内存不足时，申请内存时会怎么样？

> STL会用malloc()从堆中申请大块内存以refill内存池，如果堆内存不足，则malloc会返回空指针。
> 连堆中都没有内存，得想办法榨点内存出来，于是想到了free_list中可能还有剩，找找看有没有稍微比n字节大的内存块，只要1块就够了。
> 如果倒霉一点，连free_list中都没有找到一块比n大的内存块，并不会考虑比n小的内存块(有其原因)，而是求助于一级分配器，里面有oom机制？如果一级分配器也无能为力，那就由一级分配器抛出异常。

Q6：释放内存时，STL需要对其进行回收管理，它怎么区别这是多大的内存？

> 这一点STL很大气了，给予申请者足够的信任，申请和回收的内存块大小都是由申请者指明的，所以无需用一些机制保证这一点。本文所说的申请者是指vector、list等这些STL中需要使用分配器的数据结构。

综上，总流程已经清晰了，可以看出存在一个问题，如果堆内存紧张时，即使free_list挂了大量的空闲内存，STL管理的内存是不会吐一丁点内存出来的，但是堆又不是只有STL在用，进程所需的其他库如线程库也可能会用到的啊，大家都是兄弟，这样做就很不好了，程序运行久了之后，内存全给STL吸完了，又不肯拿出来。不过这种情况还是很难出现的，试想一下想让free_list挂满内存，应该怎么做？我能想到的就是在某个时刻STL所使用的小块内存数量达到了顶峰，顶峰过后进行回收并存放于free_list中再也没释放。
你想修改STL源码来支持彻底释放STL内存池么？回想`chunk_alloc()`的申请过程，它申请了一大块连续的内存，而STL自己把它们切成20块小的内存，打散了用链表串起来，假设我需要释放其中一小块内存，怎么释放呢？由于整块内存被打散了，free也猜不到我想释放的是哪一小块，它也无能为力，用free函数时是不能指定大小的喔～。

![image](https://github.com/xcw0754/coder-skills/blob/master/pics/CPP_501_memory_alloc_01.png)












