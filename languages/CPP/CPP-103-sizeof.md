# sizeof的细节


Q1：定义一个空类，里面没有任何成员变量和成员函数。对该类型和该类型的实例求sizeof，得到的结果是多少？
> 在G++编译器下，结果均是1。(如果一个空类的基类是空类，其sizeof结果仍是1，而不是2)

Q2：为什么不是0？
> 每个类在内存中必须占有一定内存，否则无法使用。而具体占多少内存，是编译器决定的，编译器会考虑对齐之类的事。

Q3：若在空类中添加一些普通成员函数呢？
> 结果仍均是1。成员函数不是实例独有的，而是属于类的，该类的所有实例共享，所以是不算实例所占内存的。

Q4：若在空类中添加一个虚函数呢？(涉及到虚函数知识)
> 一旦类中存在虚函数，编译器为该类生成一张虚函数表。该类型的每个实例均有一个指针指向该虚函数表起始地址，故32位机下sizeof的结果是4，即一个指针所占的内存大小。

-----
Q5：拿出一叠密密麻麻的卡片写着各种结构体的定义，sizeof(各种结构体)应该是多少？
> 本Q考的是内存对齐。内存对齐是自动进行的。若想改变对齐规则，可使用`#pragma pack(n)`指令。
> 常见类型有:char,short,int,double,char[],char*;struct,union,class。归结起来就是普通型，数组型，指针型，自定义型等几种种类型，本质上都差不多，我们只考虑其大小，而内嵌自定义类型无论多少层，每层都要满足对齐规则。
> ###### 设结构体Y中的某个变量为x，其地址为`&x`，`big=max{sizeof(x)}`则有
> - 首先，`(&x) % sizeof(x) = 0`，即x的地址必须能整除x。
> - 其次，`sizeof(Y) = big × k`，其中k为整数，为我们所要求。

> 两条规则同时满足即可。看一些实例可参考此文 [内存对齐规则之我见](https://levphy.github.io/2017/03/23/memory-alignment.html)。
> 注：GNU C 提供了`__attribute__((packed))`用于取消内存对齐。




