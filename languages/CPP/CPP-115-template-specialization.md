# 模板特化

模板特化的意思是，为模板指定特殊的实现方案。模板的类型指定得越详细，就会用越最匹配的一个来实例化。其实就是平时写的模板范围太宽了，我们想对其中几种进行特殊考虑时就要模板特化。模板分为类模板和函数模板两种。

### 类模板

先来复习一下类模板的一般写法用法：

```
template <typename T1, typename T2>
class Test
{
    ....  //类的成员变量或函数的声明
}
void main() {
    Test<int, short> a; //必须指定类型
}
```
这种写法有个小缺点，就是在实例化时，`Test<T1, T2>`中的Ti无论是什么类型的，用的都是上面定义的那个模板类。如果想写一个`Test<double, float> b`的时候，需要对Test类稍作修改怎么办？众所周知，d浮点型有时和int这些类型很不同，精度就是个很麻烦的问题，比如判断两个double变量是否相等。为了特殊处理浮点型，可以重新定义一个名字不同的模板类，比如`template <typename T1, typename T2> class TestFloat {...}`。这是不现实的，因为定义`TestFloat<int,int> e`是合法的，别有用心的人可能就会这样写，同时，同样功能的接口竟然要我背下两个类名，而且还只是因为类型的不同，我不接受。

另一种方案可以这样写：
```
template <>
class Test<double, float>
{
    ....  //类的成员变量或函数的声明
}
```
这种称为全特化。只是头两行写法不一样，这个类实质上没有模板的功能，因为类型就指定为`<double, float>`了，你要是定义`Test<char, short> c`，则都是走的`Test<T1, T2>`模板而不是`Test<double, float>`特化"模板"。

还有一种特化specialize称为偏特化，也就是一部分是指定的，一部分是泛型的。看看怎样定义的：
```
template <typename T>
class Test<double, T>
{
    ....  //类的成员变量或函数的声明
}
```
当有这样的定义`Test<double, float>`时，就走全特化。当有这样的定义时`Test<double, char>`时，就走偏特化。用一句话概括特化：优先使用最匹配的类模板来实例化。


### 函数模板

先来复习一下类模板的一般写法用法：
```
template <typename T1, typename T2>
void func(T1 a, T2 b)
{
    ...;  //具体实现
}
void main()
{
    func(2 , 3);
    func<int,int>(3, 4); //显式指定类型，只能匹配最佳的函数模板
}
```
当显式指定类型时，即使有重载函数的类型更加匹配，也只能使用模板所定义的函数。同样，当需要令这个函数模板支持特殊处理时，可以使用全特化：
```
template <>
void func(double a, float b)
{
    ...;  //具体实现
}
```
需要注意的是，函数模板并没有"偏特化"，如果真的需要那样的效果，那就用函数重载吧。比如可以这样：
```
void func(double a, char b) {...}
void func(double a, short b) {...}
void func(double a, int b) {...}
...
```
手有点软了... 函数模板和函数重载是有差别的，函数重载跟普通函数的定义一样，无论有没有地方用到这个函数，编译后都会生成代码并存在于可执行文件中，而函数模板只有在程序中使用了该函数，才会生成该函数实例的，否则可执行文件中将不会有该函数的定义。


### 总结

模板分为两种：
- 函数模板
- 类模板

模板特化方式分为3种：
- 全特化
- 偏特化
- 无特化(普通模板)

无论那一种模板，都是优先匹配最严格的模板。





