# 圆圈中最后剩下的数

### Q：将n个自然数[0, n-1]排成一个圈，从0开始每次删去圈中第m个数字，直到只剩一个数即为所求。

经典问题：约瑟夫环。略抽象，考的是数学还有观察能力。

先考虑将问题的规模变小，看能不能从小规模的问题推出大规模问题的答案。假设n>m，如果从[0, n-1]中删去第m个数，即删去`m-1`这个数()，剩下n-1个数字，分别是[0, m-1]和[m, n-1]。这能否作为小一点规模的问题递归解决？有点麻烦，因为上一次删除数字后，连续的n个数被切成不连续的两部分了，这不符合小规模的问题定义。因此得想办法将这两部分连起来，且要连续，那应该如何映射，先看下面的表中映射关系

|n规模  | 0 | 1 |...|m-2|☆| m |m+1|...|n-2|n-1|
|------|---|---|---|---|--|---|---|---|---|---|
|n-1规模|n-m|n-m+1|...|n-2| | 0 | 1 |...|n-m-2|n-m-1|

上面☆表示n规模中删除掉的数`m-1`，设
- n规模中的数字为y
- n-1规模中的数字为x

现要将x映射到y，关系式为`y = (x + m) % n`。如果知道了n-1规模的答案x，那就可以直接用这条式子来推出n规模的答案y了。当规模降到1的时候，剩下的那个数字就是1规模的答案了。代码可以这样写

```
class Solution {
public:
    int LastRemaining_Solution(int n, int m)
    {
        if(n<1 || m<1) return -1; //非法
        int last = 0; //1规模的答案
        for(int i=2; i<=n; i++) //逐次映射到i规模的答案
            last = (last + m) %i;
        return last; //n规模的答案
    }
};
```
