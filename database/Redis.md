# Redis

Redis是一个基于内存的键值对的开源存储系统，可作为数据库、缓存、消息中间件，数据可以持久化到磁盘。特点是： 
- 每秒操作10万次左右
- 支持的数据结构多
- 支持大多数编程语言
- 支持事务(不同于关系型DB的事务)
- 基于key-value存储
- 内存开销相对小
- 多种级别的异步持久化方案
- 单个value最大1GB
- 基本所有数据都用string类型
- 通过哨兵和自动分区提高可用性

局限：
- 整个数据库需load在内存中


-----
### 数据结构支持
- Strings
- Lists
- Sets
- Hashes
- Sorted Sets
- Bitmaps and HyperLogLogs

#### Key(这不是数据结构的一种)
Redis的key都是字符串，二进制安全。

#### String
字符串，它是二进制安全的，即可以存放任何数据，如图片、代码源文件。作为value时它最大512MB。

#### List
链表，它的元素是字符串，可以在头尾插删。单个List可以放(2^32 - 1)个元素，即约40亿个。插入删除是O(1)复杂度，但是访问非头尾附近元素的话时间就为O(n)了。

#### Set
集合，它的元素是字符串，无重复元素，重复则替换，元素间无序。无论集合多大，增、删和测存在性的时间复杂度均O(1)。支持集合的一般操作，如并集、交集等等。元素个数同样约40亿个。

#### Hash
哈希表，其实就是key-value，value类似于`{k1:v1;k2:v2;...}`，所有value依然是字符串。

#### Sorted Set
有序集合，元素是字符串，无重复元素，增删改任一元素都很快O(logN）。有一个score概念，它是浮点数，由用户指定，Redis根据它来对元素排序，score若相同，那就按字典序。其实有点像C++的map，只是扩展了很多操作。
	
#### Bitmaps
位图，它不是真的数据类型，是用上面的数据结构来实现的。

#### HyperLogLogs
基数统计用的。


-----
### 深入了解Redis



-----
### FAQ系列

#### Q：Redis如何保证原子性？
> A：Redis是单线程的，单个操作已是原子操作，多个操作也支持事务(使用特殊指令`multi`和`exec`包起来一个事务块)。但是它的事务却不支持回滚，只能保证在执行中不会被打断。
> Redis 2.6.5之前的版本的事务块会忽略有语法错误的命令，然后执行事务中其他正确的命令。如有3个操作，第2个失败了，第1和3是可以成功的。新版本只要有语法错误的命令，后面的就不会执行了。但是！非语法错误的其他错误命令，则不影响其他命令的成功与否。
> Redis提供了`watch`可监控多个键，一旦其中一个键有变动，则不会执行其之后的事务(认定exec)。一旦exec后，watch自然取消。原理是先watch，但事务先收下而不执行，等exec指令，只要exec指令一到，监控的键未变动，则可以处理这个事务，又因为单线程，可保证原子。
> 多客户端同时读写也是原子性的，不会出现写一半时还让其他客户端写，毕竟是单进程。

#### Q：Redis的数据持久化是怎样的？
> A：持久化是可选的，若关闭，则可能面临丢失数据风险，如断电。Redis支持两种持久化方案：RDB持久化(默认)，AOF持久化(要求较高时可选用)。
> `RDB`就是快照式持久化，根据配置来执行写盘操作，隔一段时间就写盘，且写盘是由一个子进程完成的。
> `AOF`就是通过记录数据库的写操作(像日志)，先log，再写数据库。这样只要再执行一遍即可恢复整个数据库了(可能很久，但是可边恢复边写新的数据进去)。Log通过文件记录的。AOF有3种选项：
> 1. appendfsync always 有写操作立刻同步到盘
> 2. appendfsync everysec 每秒同步一次
> 3. appendfsync no 系统决定何时同步
> 
> 分析一下，AOF是文件操作，频繁时必然IO负载重，况且，系统写盘往往也是延迟写的。所以这方面并不是Redis的优点。


#### Q：为何Redis将所有数据load在内存？
> A：为了速度。虽然它支持可持久化(还是异步的)，但是拿它当数据库用并不明智，如果数据库很小，那倒可以考虑。可以设置`maxmemory`选项来规定占用内存上限，满了还插则会报错。但是还可以通过设置LRU算法，在到达内存上限时自动删除不常用的key，就可以在满存时继续插了。

#### Q：Redis支持的过期策略有哪些？
> Q：在redis.conf中配置，称为`maxmemory policy`，有如下几种选择。`info`命令可查看占用内存状况。
>
- volatile-lru -> 使用近似的LRU算法清理那些设置过expire的key，没设置过就不会被清。
- allkeys-lru -> 所有key都可能移除，根据近似的LRU算法。
- volatile-lfu -> 使用近似的LFU算法清理那些设置过expire的key，没设置过就不会被清。
- allkeys-lfu -> 所有key都可能移除，根据近似的LFU算法。
- volatile-random -> 设置过expire的key都可能被删除，随机选的。
- allkeys-random -> 这种最随性，什么key都可能被清理，完全随机。
- volatile-ttl -> 设置过expire的那些key，具有TTL最小的key会被清
- noeviction(默认) -> 无内存回收，到达上限的写操作返回error。














