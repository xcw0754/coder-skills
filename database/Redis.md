# Redis

Redis是一个基于内存的键值对的开源存储系统，可作为数据库、缓存、消息中间件，且数据可以持久化到磁盘。

特点： 
- 每秒操作10万次左右
- 支持的数据结构多
- 支持大多数编程语言的客户端
- 支持事务(**不同于关系型DB的事务**)
- 基于key-value存储
- 内存开销相对小，灵活
- 多种级别的持久化方案
- 单个value或key最大512MB
- 基本所有数据都当成string类型存储
- 通过哨兵和自动分区提高可用性

局限：
- 整个数据库需load在内存中
- 容错性差
- RDB持久化时占用内存翻倍
- 虽是异步持久化，但仍有可能小段时间如0.02ms内无法响应客户端，仅限特殊情况

这么简单的评价必然有误，都得放到特殊情况去考虑。

-----
### 数据结构支持
- Strings
- Lists
- Sets
- Hashes
- Sorted Sets
- Bitmaps and HyperLogLogs

#### Key
Redis的key都是字符串，二进制安全。

#### String
**字符串**，它是二进制安全的，即可以存放任何数据，如图片、代码源文件。作为value时它最大512MB。

#### List
**列表**，它的元素是字符串，可以在头尾插删。单个List可以放(2^32 - 1)个元素，即约40亿个。插入删除是O(1)复杂度，但是访问非头尾附近元素的话时间就为O(n)了。

#### Set
**集合**，它的元素是字符串，无重复元素，重复则替换，元素间无序。无论集合多大，增、删和测存在性的时间复杂度均O(1)。支持集合的一般操作，如并集、交集等等。元素个数同样约40亿个。

#### Hash
**哈希表**，其实还是key-value，所有value依然是字符串。

#### Sorted Set
**有序集合**，元素是字符串，无重复元素，增删改任一元素都很快O(logN）。有一个score概念，它是浮点数，由用户指定，Redis根据它来对元素排序，score若相同，那就按字典序。

#### Bitmaps
**位图**，它不是真的数据类型，是用上面的数据结构来实现的。

#### HyperLogLogs
**基数统计**用的。



-----
### 深入了解Redis的FAQ系列

目前收集问题有：

- Redis的事务是怎样的？
- Redis的数据持久化是怎样的？
- 为何Redis将所有数据load在内存？
- Redis支持的过期策略是怎样的？有哪些？
- Redis清除过期key的过程是怎样的？
- Redis的安全性如何？
- Redis中的AOF重写是怎样实现的？
- Redis中有哪些进程和线程？各自的作用是什么？(未)
- Redis中服务端和客户端的网络通信使用什么协议通信？如何加密？(未)
- Redis的事件驱动(未)


#### Q：Redis的事务是怎样的？
> A：Redis是单线程的，单个操作已是原子操作，多个操作也支持事务(使用特殊指令`multi`和`exec`包起来一个事务块)。但是它的事务却不支持回滚，只能保证在执行中不会被打断。
> Redis 2.6.5之前的版本的事务块会忽略有语法错误的命令，然后执行事务中其他正确的命令。如有3个操作，第2个失败了，第1和3是可以成功的。新版本只要有语法错误的命令，后面的就不会执行了。但是！非语法错误的其他错误命令，则不影响其他命令的成功与否。
> Redis提供了`watch`可监控多个键，一旦其中一个键有变动，则不会执行其之后的事务(认定exec)。一旦exec后，watch自然取消。原理是先watch，但事务先收下而不执行，等exec指令，只要exec指令一到，监控的键未变动，则可以处理这个事务，又因为单线程，可保证原子。
> 多客户端同时读写也是原子性的，不会出现写一半时还让其他客户端写，毕竟是单进程。


#### Q：Redis的数据持久化是怎样的？
> A：持久化是可选的，若关闭，则可能面临丢失数据风险，如断电。Redis支持两种持久化方案：(1) RDB持久化(默认) (2) AOF持久化(要求较高时可选用)。
> - `RDB`就是**快照式持久化**，根据配置要求的时间间隔就fork一个子进程进行备份操作，进程的创建有**写时拷贝**机制，一般无需担心拷贝带来的效率影响，只是可能会CPU飙升。
> - `AOF`就是**日志式持久化**，根据配置的策略(如下)对写操作进行log到单个文件尾部，即append of file。此模式特点是灵活，有3种策略：
> 1. `appendfsync always` 主线程操作，有写操作立刻同步到盘，故主线程会阻塞。
> 2. `appendfsync everysec` 子线程操作，每秒一次同步到盘(情况复杂)，主线程不会阻塞。
> 3. `appendfsync no` 主线程操作，有写操作就会写文件，但不一定会同步到盘(情况复杂)，同步到盘时才会阻塞。
>
> 分析一下，AOF貌似很完美，并发时就会有各种情况产生，需要仔细考虑。参考[文件写入和保存](http://redisbook.readthedocs.io/en/latest/internal/aof.html#id4)


#### Q：为何Redis将所有数据load在内存？
> A：为了速度。虽然它支持可持久化(还是异步的)，但是拿它当数据库用并不明智，如果数据库很小，那倒可以考虑。可以设置`maxmemory`选项来规定占用内存上限，满了还插则会报错。但是还可以通过设置策略，在到达内存上限时自动删除特定的key，就可以在满存时继续插了。


#### Q：Redis支持的过期策略是怎样的？有哪些？
> A：内存不足时，Redis支持自动某些key以保证能够继续存储新数据。此功能在`redis.conf`文件中配置`maxmemory policy`项，有如下几种选择。
>
- `volatile-lru`  用LRU算法，设置过expire的key可能被清，没设置过就不会被清。
- `allkeys-lru`   用LRU算法，所有key都可能被移除，即使没有设置过expire。
- `volatile-lfu`  用LFU算法，设置过expire的key可能被清，没设置过就不会被清。
- `allkeys-lfu`   用LFU算法，所有key都可能被移除，即使没有设置过expire。
- `volatile-random`  随机算法，设置过expire的key都可能被清，小心使用。
- `allkeys-random`   随机算法，所有key都可能被移除，即使没有设置过expire，小心使用。
- `volatile-ttl`     设置过expire的那些key，具有TTL最小的key会被清。
- `noeviction(默认)`  无自动删除操作，内存使用到达上限时的写操作会被禁止。
>
> 如无特别说明，LRU均指的是近似LRU算法的实现，LFU同理。客户端用`INFO`命令可查看服务器端占用内存状况。


#### Q：Redis清除过期key的过程是怎样的？
> A：注意这里的**过期**仅指设置了expire的key。清除过期key有两种方式：主动、被动。
> 主动方式(lazy式)：访问某个key时会检查该key是否过期，过期则删除。
> 被动方式(定时式)：每隔一段时间(比如0.01秒，不关心)就检查，每次随机挑选m个已设expire的key，删除掉其中所有过期的key，若删除的个数(比例)过多，(从概率上看)说明过期的还有很多，则重复前面的操作，否则停下。

#### Q：Redis的安全性如何？
> Redis支持密码登陆，即客户端使用`AUTH`命令发送口令到服务端进行验证，验证通过后才可进行数据库读写操作，否则只是处于连接状态，无法操作。客户端和服务端使用纯socket通信，没有其他的加密行为。
> 如果Redis向外网开放，则会很危险。外网的客户端可尝试扫描各种端口进行连接，连接上后用穷举方式进行AUTH验证口令，只要通过了，就能进行操作了。Redis默认是没有绑定本机的，其他机器是可以连接的。
> 如果Redis只向内网开放，再加密，就稍微安全些。毕竟攻击者需要先想办法进内网才能实施攻击。
> 如果可以，对服务端提供的危险指令进行删除或妥善处理，以防客户端误操作，比如`FLUSHALL`命令。
> 再建议看看[Redis CrackIT 入侵事件分析](http://static.nosec.org/download/redis_crackit_v1.0.pdf)


#### Q：Redis中的AOF重写是怎样实现的？
> AOF重写是指，当AOF文件中冗余信息太多时，就可以用过重写操作来生成新的更简的AOF文件。比如`HSET A abc`和`HSET A cba`这样就有两条日志，但是首条是冗余的，重写后就会自动去掉首条日志。支持自动和手动(客户端命令)重写。会指令压缩，比如集合中就可以一条指令带k个value，k有规定的上限。
> 原理是，根据当前内存中的所有数据，生成新的AOF文件，在新文件成功生成完毕之前，旧的AOF文件不会被删除。重写工作由子进程处理，由于新进程的写时拷贝机制，所以不会内存翻倍或者时间效率问题。


#### Q：Redis中有哪些进程和线程？各自的作用是什么？
> 


#### Redis中服务端和客户端的网络通信使用什么协议通信？如何加密？
> Redis与客户端是TCP连接，协议为RESP（REdis Serialization Protocol，Redis序列化协议），协议很简单，客户端操作得到的回复也很简单，可能会批量回复。它们的通信没有加密措施，直接用的tcp，很容易被利用。此外，可连接的的客户端个数很少，具体数字请看源码。
> [Redis协议解析](https://my.oschina.net/coderknock/blog/993801)










